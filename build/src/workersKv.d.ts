/** Local interfaces */
import { FetchInterfaces } from './interfaces/fetch.js';
import { CloudflareResponseInterfaces } from './interfaces/cfResponse.js';
import { WorkersKvInterfaces } from './interfaces/kv.js';
/**
 * Perform Kv database operations
 * @class
 */
export declare class WorkersKv {
    private cfAuth;
    private extensionArg;
    private isValidateCfResponse;
    /**
     * @constructor
     * @see {@link https://api.cloudflare.com/#getting-started-requests}
     * @param {string} accountEmail An email of the Cloudflare account
     * @param {string} accountId An Id of the Cloudflare account
     * @param {string} apiToken An Global API key generated by Cloudflare
     * @see {@link https://dash.cloudflare.com/profile/api-tokens} to view the Global API key in your Cloudflare account.
     * @param {boolean} [isValidateCfResponse = true] True if want to validate the response sent from Cloudflare, otherwise false.
     * @param {Array[Function]} [extensionArg] Extensional function that is wanted to be executed after the database operation is performed
     * @example
     * const kvMonitor = new WorkersKvMonitor();
     * const workersKv = new WorkersKv(process.env["CF_EMAIL"], process.env["CF_ACCOUNT_ID"], process.env["CF_GLOBAL_API_KEY"], true, kvMonitor.dbListener.bind(kvMonitor));
     */
    constructor(accountEmail: string, accountId: string, globalApiKey: string, isValidateCfResponse?: boolean, ...extensionArg: Array<Function>);
    /**
     * Handling a database operation that wants to be performed.
     * It conveys a database operation request to the fetch function, receives a response from the fetch function, and send the whole database operation information to the funcArgHandlers for extensional purpose.
     * @function bridge
     * @async
     * @private
     * @param {Object} command Information about the requested database operation
     * @param {Object} http Data related to the db operation for the HTTP request
     * @returns {Promise} A full information about the HTTP request, database operation perform status, and other Cloudflare responses
     */
    protected bridge(command: WorkersKvInterfaces.BridgeCommand, http: FetchInterfaces.httpFetchOptions, validateCfResponseMethod?: "string" | "full" | "withoutResult"): Promise<FetchInterfaces.OwnFetchResponse>;
    /**
     * Sending a database operation information to the function placed in the extensionArg in the class constructor
     * @function funcArgHandlers
     * @param {(boolean | null)} processSuccess True if the database operation is completed successfully, false otherwise. Null if it is uncertain that whether the operation is completed successfully or not.
     * @param {object} command Information about the requested database operation
     * @param {object} cfFetchRes A full information about the HTTP request, database operation perform status, and other Cloudflare responses
     * @param {object} errDetail The error detail of the database operation
     */
    protected funcArgHandlers(processSuccess: boolean | null, command: WorkersKvInterfaces.BridgeCommand, cfFetchRes?: FetchInterfaces.OwnFetchResponse | null, errDetail?: {
        [key: string]: any;
    } | null): void;
    /**
     * Parsing and returning the Cloudflare response.
     * @function genReturnFromCfRes
     * @param {string} method A desired Cloudflare response format
     * @param {object} req A full information about the HTTP request, database operation perform status, and other Cloudflare responses
     * @param {string} command A short description of the performed operation.
     * @throws {WorkersKvError} The Kv operation request is failed.
     */
    private genReturnFromCfRes;
    /**
     * Returns the namespaces owned by an account
     * @function listNamespaces
     * @public
     * @see {@link https://api.cloudflare.com/#workers-kv-namespace-list-namespaces}
     * @param {object} [urlParam] The parameters that are in the URL
     * @param {number} [urlParam.page] Page number of paginated results
     * @param {number} [urlParam.perPage] Maximum number of results per page
     * @param {string} [urlParam.order] Field to order results by
     * @param {string} [urlParam.direction] Direction to order namespaces
     * @returns {Promise<object>} Information about the new namespace.
     */
    listNamespaces(urlParam?: {
        page?: number;
        per_page?: number;
        order?: "id" | "title";
        direction?: "asc" | "desc";
    }): Promise<Array<CloudflareResponseInterfaces.NamespaceRes>>;
    /**
     * Creates a namespace under the given title. A 400 is returned if the account already owns a namespace with this title. A namespace must be explicitly deleted to be replaced.
     * @function createNamespace
     * @public
     * @see {@link https://api.cloudflare.com/#workers-kv-namespace-create-a-namespace}
     * @param {object} data Data for the HTTP body that will send to Cloudflare
     * @param {string} data.title A human-readable string name for a Namespace.
     * @returns {Promise<object>} Information about the new namespace.
     */
    createNamespace(data: {
        title: string;
    }): Promise<CloudflareResponseInterfaces.NamespaceRes>;
    /**
     * Deletes the namespace corresponding to the given ID.
     * @public
     * @async
     * @function removeNamespace
     * @see {@link https://api.cloudflare.com/#workers-kv-namespace-remove-a-namespace}
     * @param {object} relativePathParam Parameters in the relative path
     * @param {string} relativePathParam.namespaceId The namespace identifier
     * @returns {boolean} True if the namespace is successfully removed, false otherwise.
     */
    removeNamespace(relativePathParam: {
        namespaceId: string;
    }): Promise<boolean>;
    /**
     * Modifies a namespace's title.
     * @public
     * @async
     * @function renameNamespace
     * @see {@link https://api.cloudflare.com/#workers-kv-namespace-rename-a-namespace}
     * @param {object} relativePathParam Parameters in the relative path
     * @param {string} relativePathParam.namespaceId The namespace identifier
     * @param {object} data Data for the HTTP body that will send to Cloudflare
     * @param {string} data.title A human-readable string name for a Namespace.
     * @returns {boolean} True if the namespace is successfully renamed, false otherwise.
     */
    renameNamespace(relativePathParam: {
        namespaceId: string;
    }, data: {
        title: string;
    }): Promise<boolean>;
    /**
     * Lists a namespace's keys.
     * @public
     * @async
     * @function listNamespaceKeys
     * @see {@link https://api.cloudflare.com/#workers-kv-namespace-list-a-namespace-s-keys}
     * @param {object} relativePathParam Parameters in the relative path
     * @param {string} relativePathParam.namespaceId The namespace identifier
     * @param {object} [urlParam] The parameters at the end of URL
     * @param {number} [urlParam.limit] The number of keys to return. The cursor attribute may be used to iterate over the next batch of keys if there are more than the limit.
     * @param {string} [urlParam.cursor] Opaque token indicating the position from which to continue when requesting the next set of records if the amount of list results was limited by the limit parameter. A valid value for the cursor can be obtained from the cursors object in the result_info structure.
     * @param {string} [urlParam.prefix] A string prefix used to filter down which keys will be returned. Exact matches and any key names that begin with the prefix will be returned.
     * @return {Promise<object>} A list of namespace's key as well as the page and cursor information.
     */
    listNamespaceKeys(relativePathParam: {
        namespaceId: string;
    }, urlParam?: {
        limit?: number;
        cursor?: string;
        prefix?: string;
    }): Promise<CloudflareResponseInterfaces.NamespaceKeysRes>;
    /**
     * Returns the value associated with the given key in the given namespace.
     * Use URL-encoding to use special characters (e.g. :, !, %) in the key name.
     * If the KV-pair is set to expire at some point, the expiration time as measured in seconds since the UNIX epoch will be returned in the "Expiration" response header.
     * @public
     * @async
     * @function readKeyValuePair
     * @see {@link https://api.cloudflare.com/#workers-kv-namespace-read-key-value-pair}
     * @param {object} relativePathParam The parameters in the relative path
     * @param {string} relativePathParam.namespaceId The namespace identifier
     * @param {string} relativePathParam.keyName The name of the key
     * @returns {Promise<string>} The key value.
     */
    readKeyValuePair(relativePathParam: {
        namespaceId: string;
        keyName: string;
    }): Promise<string>;
    /**
     * Returns the metadata associated with the given key in the given namespace. Use URL-encoding to use special characters (e.g. :, !, %) in the key name.
     * @public
     * @async
     * @function readKeyMeta
     * @see https://api.cloudflare.com/#workers-kv-namespace-read-the-metadata-for-a-key
     * @param {object} relativePathParam Parameters in the relative path
     * @param {string} relativePathParam.namespaceId The namespace identifier
     * @param {string} relativePathParam.keyName The name of the key
     * @returns {Promise<object>} An object containing the key and value of the metadata.
     */
    readKeyMeta(relativePathParam: {
        namespaceId: string;
        keyName: string;
    }): Promise<any>;
    /**
     * Write a value identified by a key.
     * Use URL-encoding to use special characters (e.g. :, !, %) in the key name.
     * Body should be the value to be stored. Existing values and expirations will be overwritten.
     * If neither expiration nor expiration_ttl is specified, the key-value pair will never expire.
     * If both are set, expiration_ttl is used and expiration is ignored.
     * @public
     * @async
     * @function writeKeyValuePair
     * @see https://api.cloudflare.com/#workers-kv-namespace-write-key-value-pair
     * @param {Object} relativePathParam Parameters in the relative path
     * @param {string} relativePathParam.namespaceId The namespace identifier
     * @param {string} relativePathParam.keyName The name of the key
     * @param {string} value A UTF-8 encoded string to be stored, up to 10 MB in length.
     * @param {Object} [urlParam] The parameters at the end of URL
     * @param {number} [urlParam.expiration] The time, measured in number of seconds since the UNIX epoch, at which the key should expire.
     * @param {number} [urlParam.expiration_ttl] The number of seconds for which the key should be visible before it expires. At least 60.
     * @returns {Promise<boolean>} True if key is successfully modified or added, false otherwise.
     */
    writeKeyValuePair(relativePathParam: {
        namespaceId: string;
        keyName: string;
    }, value: string, urlParam?: {
        expiration?: number;
        expiration_ttl?: number;
    }): Promise<boolean>;
    /**
     * Write a value identified by a key. Use URL-encoding to use special characters (e.g. :, !, %) in the key name.
     * Body should be the value to be stored along with json metadata to be associated with the key/value pair.
     * Existing values, expirations and metadata will be overwritten.
     * If neither expiration nor expiration_ttl is specified, the key-value pair will never expire.
     * If both are set, expiration_ttl is used and expiration is ignored.
     * @public
     * @async
     * @function writeKeyValuePairMeta
     * @see https://api.cloudflare.com/#workers-kv-namespace-write-key-value-pair-with-metadata
     * @param {object} relativePathParam The parameters in the relative path
     * @param {string} relativePathParam.namespaceId The namespace identifier
     * @param {string} relativePathParam.keyName The name of the key
     * @param {object} data The data that will send to Cloudflare
     * @param {string} data.value A byte sequence to be stored, up to 10 MB in length.
     * @param {object} data.metadata Arbitrary JSON to be associated with a key/value pair
     * @param {object} [urlParam] The parameters at the end of URL
     * @param {number} [urlParam.expiration] The time, measured in number of seconds since the UNIX epoch, at which the key should expire.
     * @param {number} [urlParam.expiration_ttl] The number of seconds for which the key should be visible before it expires. At least 60.
     * @returns {Promise<boolean>} True if key is successfully modified or added, false otherwise.
     */
    writeKeyValuePairMeta(relativePathParam: {
        namespaceId: string;
        keyName: string;
    }, data: {
        value: string;
        metadata: {
            [key: string]: any;
        };
    }, urlParam?: {
        expiration?: number;
        expiration_ttl?: number;
    }): Promise<boolean>;
    /**
     * Write multiple keys and values at once. Body should be an array of up to 10,000 key-value pairs to be stored, along with optional expiration information.
     * Existing values and expirations will be overwritten. If neither expiration nor expiration_ttl is specified, the key-value pair will never expire.
     * If both are set, expiration_ttl is used and expiration is ignored. The entire request size must be 100 megabytes or less.
     * @public
     * @async
     * @function writeMultipleKeyValuePairs
     * @see https://api.cloudflare.com/#workers-kv-namespace-write-multiple-key-value-pairs
     * @param {object} relativePathParam The parameters in the relative path
     * @param {string} relativePathParam.namespaceId The namespace identifier
     * @param {object} data The data that will send to Cloudflare
     * @param {string} data.key A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid.
     * @param {string} data.value A UTF-8 encoded string to be stored, up to 10 MB in length.
     * @param {number} [data.expiration] The time, measured in number of seconds since the UNIX epoch, at which the key should expire.
     * @param {number} [data.expiration_ttl] The number of seconds for which the key should be visible before it expires. At least 60.
     * @param {object} [data.metadata] Arbitrary JSON that is associated with a key
     * @param {boolean} [data.base64] Whether or not the server should base64 decode the value before storing it. Useful for writing values that wouldn't otherwise be valid JSON strings, such as images.
     * @returns {Promise<boolean>} True if keys are successfully modified or added, false otherwise.
     */
    writeMultipleKeyValuePairs(relativePathParam: {
        namespaceId: string;
    }, data: Array<{
        key: string;
        value: string;
        expiration?: number;
        expiration_ttl?: number;
        metadata?: {
            [key: string]: any;
        };
        base64?: boolean;
    }>): Promise<boolean>;
    /**
     * Remove a KV pair from the Namespace. Use URL-encoding to use special characters (e.g. :, !, %) in the key name.
     * @public
     * @async
     * @function deleteKeyValuePair
     * @see https://api.cloudflare.com/#workers-kv-namespace-delete-key-value-pair
     * @param {object} relativePathParam The parameters in the relative path
     * @param {string} relativePathParam.namespaceId The namespace identifier
     * @param {string} relativePathParam.keyName The name of the key
     * @returns {Promise<boolean>} True if the key is successfully removed, false otherwise.
     */
    deleteKeyValuePair(relativePathParam: {
        namespaceId: string;
        keyName: string;
    }): Promise<boolean>;
    /**
     * Remove multiple KV pairs from the Namespace. Body should be an array of up to 10,000 keys to be removed.
     * @public
     * @async
     * @function deleteMultipleKeyValuePairs
     * @see https://api.cloudflare.com/#workers-kv-namespace-delete-multiple-key-value-pairs
     * @param {object} relativePathParam The parameters in the relative path
     * @param {string} relativePathParam.namespaceId The namespace identifier
     * @param {object} data The data that will send to Cloudflare
     * @param {Array} data.keyName The name of the key
     * @returns {Promise<boolean>} True if keys are successfully removed, false otherwise.
     */
    deleteMultipleKeyValuePairs(relativePathParam: {
        namespaceId: string;
    }, data: {
        keyName: Array<string>;
    }): Promise<boolean>;
    /**Functions' aliases */
    read: (relativePathParam: {
        namespaceId: string;
        keyName: string;
    }) => Promise<string>;
    write: (relativePathParam: {
        namespaceId: string;
        keyName: string;
    }, value: string, urlParam?: {
        expiration?: number;
        expiration_ttl?: number;
    }) => Promise<boolean>;
    delete: (relativePathParam: {
        namespaceId: string;
        keyName: string;
    }) => Promise<boolean>;
}
